<div align=center>
    <img src="./folia.png">
    <br /><br />
    <p>専用サーバーにリージョン別マルチスレッディングを追加した、<a href="https://github.com/PaperMC/Paper">Paper</a> のフォークです。</p>
</div>

## もくじ
・[概要](#概要)  
・[よくある質問](#よくある質問)  
・[プラグインの互換性](#プラグインの互換性)  
・[APIの計画](#APIの計画)  
・[新しいルール](#新しいルール)  
・[現在のAPIの追加点](#現在のAPIの追加点)  
・[APIのスレッドコンテキストについて](#APIのスレッドコンテキストについて)  
・[現在機能しないAPI](#現在機能しないAPI)  
・[予定されているAPIの追加](#予定されているAPIの追加)  
・[予定されているAPIの変更](#予定されているAPIの変更)  
・[Maven情報](#Maven情報)  
・[ライセンス](#ライセンス)  


## 概要

Foliaは、近くにあるロードされたチャンクをグループ化して、独立した領域(以下 リージョン)を形成します。  
Foliaが近くのチャンクをどのようにグループ化するかの詳細は、
[PaperMCのドキュメント](https://docs.papermc.io/folia/reference/region-logic)を参照してください。各独立したリージョンはそれぞれ独自のティックループを持っており、通常のMinecraftのティックレート（20TPS）で処理されます。これらのティックループは、並行してスレッドプール上で実行されます。従来のメインスレッドはもはや存在せず、各リージョンが実質的に自身の「メインスレッド」としてティックループ全体を実行します。

プレイヤーが広範囲に散らばっているサーバーの場合、Foliaは多くの散らばったリージョンを作成し、設定可能なサイズのスレッドプール上でそれらを並行してティックします。したがって、このようなサーバーに対してFoliaはうまくスケールするはずです。

Foliaはそれ自体が独立したプロジェクトであり、予見可能な将来においてPaperに統合されることはありません。

詳細な概要は、[プロジェクト概要](https://docs.papermc.io/folia/reference/overview)をご覧ください。

## よくある質問
Foliaがもたらす利点を享受できるサーバータイプはどのようなものですか？
プレイヤーが自然に散らばるサーバータイプ、例えばスカイブロックやSMPなどがFoliaの恩恵を最も受けやすいです。また、かなりの数のプレイヤーを抱えるサーバーが適しています。

## Foliaはどの種類のハードウェアで最も効率良く動作しますか？
理想的には、少なくとも16のコア（スレッドではありません）が必要です。

## Foliaを最適に設定するにはどうすればよいですか？
まず、ワールドが事前に生成されていることが推奨され、これにより必要とされるチャンクシステムワーカースレッドの数を大幅に削減できます。

以下は、Foliaがテストサーバーでリリースされる前に行われたテストに基づく非常に大まかな見積もりです。そのテストサーバーではピーク時に約330人のプレイヤーがいました。従って、これは正確な数値ではなく、さらなるチューニングが必要です。出発点として考えてください。

マシンで利用可能なコアの総数を考慮した上で、以下にスレッドを割り当てます：

netty IO：200-300人のプレイヤーにつき約4スレッド
チャンクシステムIOスレッド：200-300人のプレイヤーにつき約3スレッド
事前に生成された場合のチャンクシステムワーカー：200-300人のプレイヤーにつき約2スレッド
事前に生成されていない場合のチャンクシステムワーカーについては、最良の推測はできません。実際にテストサーバーで16スレッドを割り当てましたが、約300人のプレイヤーがいる時でもチャンク生成は遅延しました。
GC設定：???? ただし、GC設定によっては並列スレッドが割り当てられるため、正確な数を把握する必要があります。これは通常 -XX:ConcGCThreads=n フラグによって設定されます。このフラグを -XX:ParallelGCThreads=n と混同しないでください。なぜなら並列GCスレッドはGCがアプリケーションを一時停止させた時にのみ実行されるため、考慮に入れるべきではないからです。 これらの割り当てを行った後、システム上の残りのコアを80%までの割り当て（割り当てられた総スレッドが利用可能なCPUの80%未満）で、tickthreads（グローバル設定の下、threaded-regions.threads）に振り分けることができます。
80%以上のコアを割り当てない理由は、プラグインやサーバー自体が予測もしくは設定できない追加のスレッドを利用する可能性があるためです。

以上はすべてプレイヤー数に基づいた大まかな見積もりであり、実際にはスレッド割り当てが理想的でない可能性が高く、実際のスレッド使用状況に基づいて調整する必要があるでしょう。

## プラグインの互換性

メインスレッドはもはや存在しません。Foliaで機能するためには、全てのプラグインに_ある程度の_変更が必要になると予想されます。さらに、あらゆる種類のマルチスレッディングはプラグインが保持するデータに競合状態を引き起こす可能性があるため、変更が避けられないでしょう。

従って、互換性についての期待はしないようにしてください。

## APIの計画

現在、多くのAPIがメインスレッドに依存しています。
Paperと互換性のあるプラグインがFoliaと互換性を持つとはほとんど考えられません。しかし、FoliaのプラグインがPaperと互換性を持つようにAPIを追加する計画があります。

例えば、Bukkitスケジューラーは、本質的に単一のメインスレッドに依存しています。FoliaのRegionSchedulerやEntitySchedulerは、特定のリージョンが「所有する」場所やエンティティの「次のティック」にタスクをスケジュールする機能を提供します。これらは通常のPaper上で実装することができますが、メインスレッドにスケジュールされることはなく、タスクの実行は場所やエンティティを「所有する」スレッドで行われます。この概念は一般的に適用され、現在のPaper（シングルスレッド）はすべての世界の全てのチャンクを包含する一つの大きな「リージョン」と見なすことができます。

このAPIをPaper自体に直接追加するか、それともPaperlibに追加するかはまだ未定です。

## 新しいルール

Foliaは多くのプラグインを使用不能にします。どのプラグインが動作するかをユーザーが把握できるように、作者が明示的にFoliaで動作するとマークしたプラグインのみがロードされることになります。プラグインのplugin.ymlに「folia-supported: true」と記述することで、プラグインの作者はそのプラグインが領域化マルチスレッディングに対応していると宣言できます。

もう一つ重要なルールは、リージョンが_並列に_ティックされるということです。_同時実行_ではありません。リージョン間でデータは共有されず、共有予定もなく、データの共有は_必ず_データ破損を引き起こします。
あるリージョンで実行されているコードは、いかなる状況下でも他のリージョンにあるデータにアクセスしたり変更したりしてはなりません。マルチスレッディングが名前に含まれているからといって、全てがスレッドセーフになっているわけではありません。実際には、この目的のためにスレッドセーフにされた部分は_ごくわずか_です。時間が経つにつれて、スレッドコンテキストチェックの回数は増える一方です。たとえそれがパフォーマンスにペナルティを伴うとしても、バグだらけのサーバープラットフォームで作業する人は_誰もいない_でしょうし、これらのバグを防ぎ発見する唯一の方法は、不正なアクセスをその発生源で_厳しく_取り締まることです。

これは、Folia互換のプラグインがRegionSchedulerやEntitySchedulerのようなAPIを活用して、そのコードが正しいスレッドコンテキストで実行されることを確実にする必要があることを意味します。

一般的に、イベントの発生源から約8チャンクの範囲内のチャンクデータをあるリージョンが所有していると考えるのは安全です（例えば、プレイヤーがブロックを破壊した場合、そのブロックの周りの8チャンクにアクセスできるでしょう）。しかしこれは保証されているわけではなく、プラグインは正しい動作を保証するために、今後提供されるスレッドチェックAPIを利用するべきです。

スレッドセーフティの唯一の保証は、特定のチャンクのデータを単一のリージョンが所有しているという事実に由来します。そしてそのリージョンがティックしている場合、そのデータに完全にアクセスできるということです。このデータは具体的にはエンティティ、チャンク、POIデータを指し、どのプラグインのデータとも無関係です。

通常のマルチスレッディングの規則は、プラグインが自身のデータや他のプラグインのデータを保存・アクセスする場合に適用されます。イベントやコマンドなどは、リージョンが_並列に_ティックしているため_並列に_呼び出されます（同期的な方法で呼び出すことはできません。これはデッドロックの問題を引き起こし、パフォーマンスを制限するためです）。これには簡単な解決策はなく、完全にアクセスされているデータに依存します。時にはConcurrentHashMapのような並行コレクションが十分かもしれませんが、しばしば不注意に使用されるとスレッディングの問題を_隠す_だけであり、それによってデバッグが極めて困難になることがあります。

### 現在のAPIの追加点

API追加を正しく理解するためには、[プロジェクト概要](https://docs.papermc.io/folia/reference/overview)をご覧ください。

- BukkitSchedulerに代わるものとして機能するRegionScheduler、AsyncScheduler、GlobalRegionScheduler、およびEntitySchedulerです。エンティティスケジューラーはEntity#getSchedulerを通じて取得でき、その他のスケジューラーはBukkit/Serverクラスから取得可能です。
- 現在のティックを行っている地域が特定の位置やエンティティを所有しているかどうかをテストするBukkit#isOwnedByCurrentRegionメソッド。

### APIのスレッドコンテキストについて

API追加を正しく理解するためには、[プロジェクト概要](https://docs.papermc.io/folia/reference/overview)をご覧ください。

一般的な指針:

1. エンティティやプレイヤーに対するコマンドは、そのエンティティやプレイヤーを所有するリージョンで実行されます。コンソールコマンドはグローバルリージョンで実行されます。

2. 単一のエンティティに関連するイベント（例: プレイヤーがブロックを破壊/設置する場合）は、そのエンティティを所有するリージョンで実行されます。エンティティに対する行動を伴うイベント（例: エンティティがダメージを受ける場合）は、対象のエンティティを所有する地域で呼び出されます。

3.イベントのasync修飾子は非推奨です - 地域またはグローバルリージョンから発生するイベントは、もはやメインスレッドがないにもかかわらず、_同期的_と見なされます。

### 現在機能しないAPI

- ポータルとの連携、プレイヤーのリスポーン、一部のプレイヤーのログインAPIなど、多くのAPIが機能していません。
- 全てのスコアボードAPIは機能しないと見なされます（これはまだ適切な実装方法が見つかっていないグローバル状態です）。
- ワールドのロード/アンロードが機能しません。
- Entity#teleportは、_どんな状況下でも_機能しません。代わりにteleportAsyncを使用してください。
- その他、機能しない可能性のあるAPIが多数存在します。

### 予定されているAPIの追加

- 適切な非同期イベントの導入。これにより、イベントの結果を後から異なるスレッドコンテキストで完了させることが可能になります。これは、リージョン外のチャンクデータにアクセスする際に非同期のチャンクロードが必要な場合など、いくつかの実装に必要になります。
- ワールドのロード/アンロード
- その他、追加予定のAPIがあります。

### 予定されているAPIの変更

- 徹底したスレッドチェックが全面的に導入されます。これは、ランダムな部分のサーバーを完全に_診断不能な_状態にする可能性のあるコードをプラグイン開発者が出荷するのを防ぐために不可欠です。
- その他、変更予定のAPIがあります。

### Maven情報
* Mavenリポジトリ（folia-api用）:
```xml
<repository>
    <id>papermc</id>
    <url>https://repo.papermc.io/repository/maven-public/</url>
</repository>
```
* アーティファクト情報：
```xml
<dependency>
    <groupId>dev.folia</groupId>
    <artifactId>folia-api</artifactId>
    <version>1.20.1-R0.1-SNAPSHOT</version>
    <scope>provided</scope>
</dependency>
 ```


## ライセンス
PATCHES-LICENSEファイルは、APIおよびサーバーパッチのライセンスに関する情報を記述しています。これらは./patchesディレクトリおよびそのサブディレクトリに位置しており、特別な注記がない限りはその範囲に含まれます。

このフォークは、[こちら](https://github.com/PaperMC/paperweight-examples)にあるPaperMCのフォーク例を基にしています。したがって、本プロジェクトにはそれに対する変更が含まれており、変更されたファイルのライセンス情報については該当のリポジトリで確認してください。


## License
The PATCHES-LICENSE file describes the license for api & server patches,
found in `./patches` and its subdirectories except when noted otherwise.

The fork is based off of PaperMC's fork example found [here](https://github.com/PaperMC/paperweight-examples).
As such, it contains modifications to it in this project, please see the repository for license information
of modified files.

