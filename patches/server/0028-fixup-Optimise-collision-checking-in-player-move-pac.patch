From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 12 Sep 2023 05:00:36 -0700
Subject: [PATCH] fixup! Optimise collision checking in player move packet
 handling


diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 678bba9d636a0eb34270a2d26b5b3d0d6d900115..a1a931095c41126a05e806541075ccc40b9ea8f9 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1742,22 +1742,29 @@ public class ServerGamePacketListenerImpl implements ServerPlayerConnection, Tic
     // Paper end
     // Paper start - optimise out extra getCubes
     private boolean hasNewCollision(final ServerLevel world, final Entity entity, final AABB oldBox, final AABB newBox) {
-        final List<AABB> collisions = io.papermc.paper.util.CachedLists.getTempCollisionList();
-        try {
-            io.papermc.paper.util.CollisionUtil.getCollisions(world, entity, newBox, collisions, false, true,
-                true, false, null, null);
+        final List<AABB> collisionsBB = new java.util.ArrayList<>();
+        final List<VoxelShape> collisionsVoxel = new java.util.ArrayList<>();
+        io.papermc.paper.util.CollisionUtil.getCollisions(
+            world, entity, newBox, collisionsVoxel, collisionsBB,
+            io.papermc.paper.util.CollisionUtil.COLLISION_FLAG_COLLIDE_WITH_UNLOADED_CHUNKS | io.papermc.paper.util.CollisionUtil.COLLISION_FLAG_CHECK_BORDER,
+            null, null
+        );
 
-            for (int i = 0, len = collisions.size(); i < len; ++i) {
-                final AABB box = collisions.get(i);
-                if (!io.papermc.paper.util.CollisionUtil.voxelShapeIntersect(box, oldBox)) {
-                    return true;
-                }
+        for (int i = 0, len = collisionsBB.size(); i < len; ++i) {
+            final AABB box = collisionsBB.get(i);
+            if (!io.papermc.paper.util.CollisionUtil.voxelShapeIntersect(box, oldBox)) {
+                return true;
             }
+        }
 
-            return false;
-        } finally {
-            io.papermc.paper.util.CachedLists.returnTempCollisionList(collisions);
+        for (int i = 0, len = collisionsVoxel.size(); i < len; ++i) {
+            final VoxelShape voxel = collisionsVoxel.get(i);
+            if (!io.papermc.paper.util.CollisionUtil.voxelShapeIntersectNoEmpty(voxel, oldBox)) {
+                return true;
+            }
         }
+
+        return false;
     }
     // Paper end - optimise out extra getCubes
     private boolean isPlayerCollidingWithAnythingNew(LevelReader world, AABB box, double newX, double newY, double newZ) {
