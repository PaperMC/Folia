From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Shanyu Juneja <shanyujuneja@gmail.com>
Date: Mon, 10 Jul 2023 20:52:42 +0200
Subject: [PATCH] Implement EntityTeleportEvent properly

Many things to express. This change implements the EntityTeleportEvent in a context thread safe way. The following are handled:
- Passengers have the event called properly
- Recursion is prevented by checking for the teleport status. Such status is revoked by overriding and chaining the teleport callback. It is manually removed when the event fails and henceforth the callback would call null, or when the entities are in the same chunk region, and hence don't call the callback.
- Teleporting status is removed on callback
- Modifying the teleport location of passenger entities is forbidden to prevent conflicts
- Cancelling an entity riding will dismount it and NOT trigger any events for its passengers

diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index ee15661227754149164893d6acf678d13b2e1b27..2754bf8b742750017f1317422e90ccec3c0cafdf 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -9,18 +9,11 @@ import com.google.common.collect.UnmodifiableIterator;
 import com.mojang.logging.LogUtils;
 import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
 import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Set;
-import java.util.UUID;
+
+import java.util.*;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.function.BiConsumer;
+import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
@@ -125,6 +118,8 @@ import net.minecraft.world.phys.shapes.Shapes;
 import net.minecraft.world.phys.shapes.VoxelShape;
 import net.minecraft.world.scores.PlayerTeam;
 import net.minecraft.world.scores.Team;
+import org.bukkit.World;
+import org.bukkit.event.entity.*;
 import org.slf4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
@@ -135,7 +130,6 @@ import org.bukkit.craftbukkit.event.CraftPortalEvent;
 import org.bukkit.entity.Hanging;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Vehicle;
-import org.bukkit.event.entity.EntityCombustByEntityEvent;
 import org.bukkit.event.hanging.HangingBreakByEntityEvent;
 import org.bukkit.event.vehicle.VehicleBlockCollisionEvent;
 import org.bukkit.event.vehicle.VehicleEnterEvent;
@@ -146,11 +140,6 @@ import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.util.CraftLocation;
 import org.bukkit.entity.Pose;
-import org.bukkit.event.entity.EntityAirChangeEvent;
-import org.bukkit.event.entity.EntityCombustEvent;
-import org.bukkit.event.entity.EntityDropItemEvent;
-import org.bukkit.event.entity.EntityPortalEvent;
-import org.bukkit.event.entity.EntityPoseChangeEvent;
 import org.bukkit.event.player.PlayerTeleportEvent;
 import org.bukkit.plugin.PluginManager;
 // CraftBukkit end
@@ -549,6 +538,16 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
     public final long referenceId = REFERENCE_ID_GENERATOR.getAndIncrement();
     // Folia end
     // Folia start - region ticking
+    private boolean teleporting;
+
+    public boolean isTeleporting() {
+        return teleporting;
+    }
+
+    public void setTeleporting(boolean teleporting) {
+        this.teleporting = teleporting;
+    }
+
     public void updateTicks(long fromTickOffset, long fromRedstoneTimeOffset) {
         if (this.activatedTick != Integer.MIN_VALUE) {
             this.activatedTick += fromTickOffset;
@@ -3836,7 +3835,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         if (!this.canTeleportAsync()) {
             return false;
         }
-        this.getBukkitEntity(); // force bukkit entity to be created before TPing
+        org.bukkit.entity.Entity bukkitEntity = this.getBukkitEntity(); // force bukkit entity to be created before TPing
         if ((teleportFlags & TELEPORT_FLAG_UNMOUNT) == 0L) {
             for (Entity entity : this.getIndirectPassengers()) {
                 if (!entity.canTeleportAsync()) {
@@ -3858,7 +3857,134 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             }
         }
 
-        // TODO any events that can modify go HERE
+        // --- Event handling
+        this.setTeleporting(true);
+
+        // If teleport is successful, set the teleporting status BEFORE calling the callback. This
+        // effectively prevents, as seen above, from recursive teleportation, but allows for chained
+        // teleportation.
+
+        // TODO:    This is a hack to allow for chained teleportation. There is an important need for
+        //          an api change to support culling, returning back what entity was attempted to be
+        //          teleported and what the status of such teleportation attempt was
+        //
+        //          eg:
+        //          TeleportOutput (
+        //              Entity entity,
+        //              ResultType resultType,
+        //
+        //              isSuccees() -> boolean [resultType == SUCCESS],
+        //              isFailed() -> boolean [resultType == CANCELLED || resultType == CANCELLED_VEHICLE || resultType == ERROR]
+        //          )
+        //
+        //          ResultType (SUCCESS, CANCELLED, CANCELLED_VEHICLE, ERROR)
+        //
+        final java.util.function.Consumer<Entity> previousConsumer = teleportComplete;
+        teleportComplete = entity -> {
+            if (entity != null) {
+                final EntityTreeNode tree = entity.detachPassengers();
+                for (final EntityTreeNode entityNode : tree.getFullTree()) {
+                    entityNode.root.setTeleporting(false);
+                }
+            }
+
+            previousConsumer.accept(entity);
+        };
+
+        // Grab original location
+        final Location from = this.getBukkitEntity().getLocation();
+        Location to =  new Location(
+            destination.getWorld(),
+            pos == null ? this.getX() : pos.x,
+            pos == null ? this.getX() : pos.y,
+            pos == null ? this.getX() : pos.z,
+            yaw == null ? bukkitEntity.getLocation().getYaw() : yaw,
+            pitch == null ? bukkitEntity.getLocation().getPitch() : pitch
+        );
+
+        // Special event exclusively for players.
+        to = callBukkitTeleport(from, to, cause, teleportComplete);
+
+        if (to == null) {
+            return false;
+        }
+
+        // Update the events accordingly.
+        pos = new Vec3(
+            to.getX(),
+            to.getY(),
+            to.getZ()
+        );
+        yaw = to.getYaw();
+        pitch = to.getPitch();
+
+        // End of event handling
+
+        if (!this.getPassengers().isEmpty()) {
+            final EntityTreeNode passengerTree = this.detachPassengers();
+
+            // Failsafe
+            if (passengerTree.passengers == null) {
+                throw new IllegalStateException("Passenger tree root must not be null");
+            }
+
+            // First handle all events
+            // This is a DFS. Here's one issue one may think of. Let's assume we have three entities.
+            // We have Player 1, Player 2, and Player 3. Player 1 is riding Player 2, and
+            // Player 2 is riding Player 3. If we teleport Player 1, we must teleport Player 2
+            // But let's assume player 1 cancels the event, then he will be dismounted from player 2.
+            // But what if player 2 also cancels the event? Then player 2 will be dismounted from player 3
+            //
+            // This is why we must perform a BFS correctly and manually. This also improves redundant
+            // teleport calls for entities that won't be teleported anyway
+            final Stack<EntityTreeNode> entityStack = new Stack<>();
+            entityStack.addAll(Arrays.asList(passengerTree.passengers)); // Add all passengers
+
+            while (!entityStack.isEmpty()) {
+                final EntityTreeNode entityNode = entityStack.pop();
+                final Entity entity = entityNode.root;
+                final org.bukkit.entity.Entity bukkitPassengerEntity = entity.getBukkitEntity();
+
+                // TODO:    Temporary whilst api changes are discussed and implemented
+                //          The property teleporting is removed due to entity nbt data
+                //          being saved and loaded.
+                entity.setTeleporting(true);
+
+                // Teleport action
+                // Must perform clone as location is mutable. Make sure to prevent the location from modified
+                final Location previous = to.clone();
+                to = entity.callBukkitTeleport(
+                        bukkitPassengerEntity.getLocation(),
+                        to,
+                        cause,
+
+                        // TODO:    Discuss this. Should we be including the teleport complete callback?
+                        //          The bukkit teleport ONLY calls the callback if the event was cancelled
+                        //          or has failed, which is most the time ONLY relevant for the main entity,
+                        //          not the passengers.
+                        e -> {}
+                );
+
+                // If the event was cancelled, we need to unmount the entity and restore the location
+                if (to == null) {
+                    entity.stopRiding(true); // Suppress cancel, we must force this action
+                    entity.setTeleporting(false);
+
+                    to = previous;
+                    continue;
+                }
+
+                // Prevent riding entities from changing the destination location
+                if (!previous.equals(to)) {
+                    throw new UnsupportedOperationException("Teleporting entities whilst they are riding another entity is not supported");
+                }
+
+                // Add all passengers
+                if (entityNode.passengers != null) {
+                    entityStack.addAll(Arrays.asList(entityNode.passengers));
+                }
+            }
+        }
 
         // check for same region
         if (destination == this.level()) {
@@ -3871,6 +3997,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                 )
             ) {
                 EntityTreeNode passengerTree = this.detachPassengers();
+
                 // Note: The client does not accept position updates for controlled entities. So, we must
                 // perform a lot of tracker updates here to make it all work out.
 
@@ -3878,6 +4005,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
                 passengerTree.clearTracker();
                 for (EntityTreeNode entity : passengerTree.getFullTree()) {
                     entity.root.teleportSyncSameRegion(pos, yaw, pitch, speedDirectionUpdate);
+                    entity.root.setTeleporting(false); // No callback, we must force this action
                 }
 
                 passengerTree.restore();
@@ -3898,6 +4026,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         }
 
         EntityTreeNode passengerTree = this.detachPassengers();
+
         List<EntityTreeNode> fullPassengerTree = passengerTree.getFullTree();
         ServerLevel originWorld = (ServerLevel)this.level;
 
@@ -3907,6 +4036,7 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
 
         for (EntityTreeNode node : fullPassengerTree) {
             node.root = node.root.transformForAsyncTeleport(destination, pos, yaw, pitch, speedDirectionUpdate);
+            node.root.setTeleporting(true); // hotfix
         }
 
         passengerTree.root.placeInAsync(originWorld, destination, teleportFlags, passengerTree, teleportComplete);
@@ -3914,6 +4044,57 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
         return true;
     }
 
+    protected @Nullable Location callBukkitTeleport(Location from, Location to, PlayerTeleportEvent.TeleportCause cause,
+                                                    Consumer<Entity> teleportComplete) {
+        org.bukkit.entity.Entity bukkitEntity = this.getBukkitEntity(); // force bukkit entity to be created before TPing
+
+        // Prevent recursive action. Teleports should
+        if (this.isTeleporting()) {
+            throw new IllegalStateException(
+                "Entity is already teleporting. Please do not teleport an entity inside a EntityTeleportEvent listener."
+            );
+        }
+
+        if (this instanceof Player) {
+            PlayerTeleportEvent event = new PlayerTeleportEvent(
+                (org.bukkit.entity.Player) bukkitEntity,
+                from,
+                to,
+                cause,
+                new HashSet<>() // Unsupported by API currently.
+            );
+
+            if (event.callEvent()) {
+                teleportComplete.accept(null);
+                return null;
+            }
+
+            to = event.getTo();
+        } else {
+            EntityTeleportEvent event = new EntityTeleportEvent(
+                bukkitEntity,
+                from,
+                to
+            );
+
+            if (event.callEvent()) {
+                teleportComplete.accept(null);
+                return null;
+            }
+
+            to = event.getTo();
+        }
+
+        // Failsafe
+        if (to == null) {
+            throw new IllegalStateException(
+                "EntityTeleportEvent#getTo() returned null - This is illegal behaviour. Please instead cancel the event."
+            );
+        }
+
+        return to;
+    }
+
     public void preChangeDimension() {
 
     }
